# Изучение паттернов 


## Введение в шаблонны и паттерны поведения
**Шаблон** — Можно использовать сразу  
**Паттерн** — Нужно адаптировать под себя  
**Идеомы** — Уже свойствены какому-либо языку

**Паттерны делятся на 3 группы**
- Порождающие
- Поведенческие
- Структурные

## Что дают паттерны
- Готовые решения
- Сокращается время на разработку
- Выявлены все проблемы и примущества
- Упрощается чтение кода
- Можно модифицировать программу без изменения кода

## Порождающие паттерны
Если мы рассматриваем, что данная сущность будет изменяться, то мы обязаны выделить для нее базовую абстракцию.  

Мы работаем с указателем или с ссылкой на базу при полиморфизме

```c++
{
    std::shared_ptr<A> obj = std::make_shared<B>();
    // Заменим на
    std::shared_ptr<A> obj = cr->create();
}
```

**Проблема:** мы вынуждены создавать конкретный объект, конкретного класса.

Мы можем подменить одно на другое, для этого в коде придется искать, где создается объект 

```c++
class Creator
{
public:
    virtual std::unique_ptr<Product> create() = 0;
}

template <typename T>
class conCreator : public Creator
{
public:
    std::unique_ptr<Product> create() override
    {
        return std::make_unique<T>();
    }
}
```

каждый раз создается объект, что неразумно. Лучше один раз создать и далее его использовать.


## 1. Curiously recurring template pattern (CRTP)


## 2. Идиома NVI - Non Virtual Onerface

недостатки Creator:
- Мы должны таскать во все методы Cretor для создания объектов
  
**Идея:** Возложить ответственность за создания новых продуктов на сам продукт

## 3. Паттерн прототип
## ПРОРАБОТАТЬ
Мы до dбавляем виртуальный метод `clone()` 
```c++
{
    // Иерархия классов: (A, clone()) <-  (B, clone()) <- (C)
    A *p = new C;
    A *p1 = p->clone(); // Вызовется метод B::clone
    // Можем сравнить типы объектов на этапе выполнения при помощи typeid
    // Но это происходит во вне, но нам надо это сделать внутри продукта
    // Проверяем это внутри GetProduct() 
}
```

Бывают объекты, которые относятся к отдному семейству
- Например, используем графическую библиотеку. Есть объект graphics. (pen(), brush())  
- Мы не можем использоать объекты из одной библиотеки вместе с этим
- Нужен контроль, чтобы создавались объекты одного семейства

**Идея:** Иерархии объединить в одну

## 4. Паттерн абстрактная фабрика
В одном классе написать несколько creator-ов, которые будут создавать объекты этого семейства

Недостатки:
- Тот же недостаток для обычного Creator
- В семействх объекты бывают неравносильными, каких-то классов в семействе не будет
- Надо реализовать свои классы, которые будут уравновешивать это

## 5. Паттерн: Пул объектов
Можно реализовать как Creator
- Он должен держать много объектов
- Мы попросили объект, он нам одалживает его, а мы занимаем. Значит другой не может использовать этот объект
- Попользовались и отдали

## 6. Антипаттерн: Одиночка (SingleTon)
Создание сложного объекта
- Чтобы создать объект нужно выполнить несколько действий
Это все выделяем в отдельный класс
Builder <---<> Director ----> Creator

```c++
class Builder
{
    build_part_1()
    build_part_2()
}

class Director
{
    creator()
}
```

`Direcotr` не должен "таскать кирпичи" для `Builder и Director`-a включать в общую иерархию создателей

# Структурные паттерны
## 6. Паттерн: Адаптер
Один объект может выполнять несколько ролей. Если так,то мы должны расщеплять его. Разделить на несколько ролей.  
- Одна и та же часть интерфейса может выполнять несколько ролей
- Один метод может выполняться как разные роли

**Задача:** Сделать так, чтобы можно было независимо разбивать роли. Как расщепить?
- Делаем сам объект очень простым. Он имеет геттеры и сеттеры
Если используем std, то с ее сущностями работаем только через адаптер.

**Правило** голых библиотечных контейнеров не используем, только через адаптер.  

Расширение интерфейсов достижимо при помощи адаптера   
**Недостатки:**
- Увеличивается иерархия
- Все держится на полиморфизме, увеличивается колво памяти
- Выделеи разные роли, но интерфейсы могут пересекаться
- Уходим от реализации  обобщению, значит мы должны реплизовать кучу оберток

## 7. Декоратор
(class A, methods: draw()) <----- (class B, methods:draw()) <------------ (class C, methods:draw())
```c++
void C:draw()
    ...
    B:draw();
    ...

class Shape;
class Model1 : shape;
class Model.. : shape;
class ModelN : shape;
class Smth : Model1; // Добавляем что-то еще

// Разрастается иерархия
// Если надо что-то объединить, то множественное наследование и тп. РОМБ - плохо
```
**Идея** — вынести изменения в отедльные сущности. Они будут оорачивать исходный объект
Это — декоратор
```c++
void Decorator::draw()
{
    ...
    B:draw();
    shape->draw();
    ...
}
```

**Плюсы:**  
- Для микса — можно продекорировать сам декоратор сколько угодно раз
- Для созданияя объектов Model1, .., Creator и  Solution будут простыми
- Во времяы выполнения можно менять поведение объектов

**Проблемы**  
- Для декораторов нужно усложнять Creator и Solution
- Мы вынуждены заново декорировать, чтоы изменить/удалить декоратор
- Вместо роста иерархии моделей, разрастается иерархия декораторов.
- Из-за вирутальных таблиц увеличивается время выполнения


## 8. Паттерн: Композит
В 3ей лр. Есть объекты: визуализируемые и нет. Однако со всеми ними можно проводить одни и те же действия: масштаб, поворот, и тп. Формируем список. Органиуем цикл и проходимся по этому списку. И выполняем действие. Это не очень удобно.  
**Идея:** список вынести (спрятать в отдельные сущности). Эта сущность - сущность сцены. Мы должны уметь выполнять над этой группой выполнять все те же действия, что и над любым другим объектом сцены.  
Используется прием выталкивания интерфейса.  
Добавляем в интерфейс компонента: add, remove, begin, end, isComposite (ты кто?).  
Если мы формируем списки объектов, имеющих какойто интерфейс, то надо эти объекты заключать в композит. Правило: мы не работаем со стандартными контейнерами напрямую, только через композит!.  
Мы всегда должны выделять сущности "решал", которые должны этот композит формировать (довольно тяжелая логика).  
Сам композит входит в иерархию. Нам не важно, модель это или композит. Поэтому композит может быть компонент. Это значит, что в композите могут быть композиты и так далее.  
Нам надо каким то образом надо просмотреть все, что содержится в композите, т.е. надо учитывать вложенность. Кто-то должен держать итератор на этот композит.  

## 9. Паттерн: Мост
В декораторе мы можем не вызывать метод базы. Тогда декоратор не будет декорировать, он будет заниматься подменой какого-либо метода. Поэтому может возникнуть проблема дублирования кода.  
Посколько мы работаем с реализацией, то идея вынести реализацию в отдельную иерархию  
Выделим реализацию в отдельную иерархию, имеющую свой интерфейс.  
Из-за данных мы этот мост не всегда можем свести к базовым абстракциям.

## 10 Паттерн Заместитель (Proxy)
Проблема: предположим, что есть какая-то сущность и объекты могут работать с БД. Запрос может выполняться долго. Получили результат. Предположим, что следующий запрос был таким же. В целом, БД кешируют запросы. Поэтому первый запрос долгий, а потом быстрее. Но часто там хранится немного информации. Поэтому основная его задача - загрузить в память индексы. Поэтому нужно кешировать данные где-то в программе. Адаптер может решить эту проблему. Но с ним может быть проблема (он в другой иерархии).  

**Идея** — работать с сущностью так же как и с объектом.

Прокси держит указатель на сам объект. Это может быть как агрегация, так и композиция. Так как мы работаем с указателем на базовую абстракцию, то мы в коде можем спокойно подменить сам объект на прокси. И сам прокси будет, например, кешировать запросы.  
Объект может поменяться, поэтому когда-то инфорация может стать нерелевантной. Должна быть какая-то рефлексия.  
Прокси может в целом работать без самого объекта. Например, прокси может сам отвечать на простые запросы.  
Объекта уже нет, но есть прокси, и мы можем получать ответы, когда самого объекта уже нет.  
Прокси может кодировать, декодировать, фильтровать, преобразовывать запросы. Может собирать статистику и аналитику.  

## 11 Паттерн Фасад
Если нам важны связи между объектами, то надо спрятать весь этот "мир" объектов за оболочкой. То есть он должен предоставлять какой-то интерфейс для взаимодействия с этим "миром".  
Это дает возможность создать интерфейс для работы с этим миром  

# Поведенческие паттерны
## 12. Паттерн стратегия (Strategy)
Мы не можем использовать просто какие-то отдельностоящие функции в ООП. Идея - обернуть ее в класс.
В зависимости от того, что мы хотим, можем использовать разные стратегии.
Любую реализацию можно вынести в стратегию.

**Плюсы:**
- Если сравнивать с другими паттернами, мы через этот метод можем легко передавать данные стратегии.

**Проблемы:**
- Разные сущности могут иметь разные данные, поэтому стратегия завязывается под конкретную сущность. Поэтому придется плодить кучу иерархий стратегий.

## 13. Паттерн команда
Команда - оболочка, держащая пару объект, метод и данные. И единственный метод - `execute()` 
Команда может разбиваться на несколько подкоманд (например, удаляем старый рисунок, поворачиваем, рисуем новый).  
Это поведенческий паттерн, но похож на структурный паттерн (композит).  
**Проблемы:**
- На уровне интерфейса мы должны знать, что происходит в прикладном домене - плохо.
- Можно выделить посредника (прослойку), чтобы интерфейс не знал о прикладном домене
- Мы "дергаем" один метод. Запрос адресован кому-то одному. А что если один и тот же запрос должны выполнять несколько объектов?

**Идея:** отвязать интерфейс от прикладного домена. И сделшать возможность, чтобы те кто может принимать этотт запрос, сами решали бы, нужен ли им этот запрос?

## 14. Паттерн Цепочка обязанностей
1. Сформировали запрос
2. Переддаем его прикладному домену
3. Запускаем его по цепочке обработчиков
4. Уже сами обработчики будут решать, нужен ли ему этот запрос  

Мы можем динамически менять список обработчиков. Получаем довольно гибкую схему.

**Проблема**
- Обработчик должен как-то понять, может ли он обработать этот запрос.
- Также, надо еще как-то получить данные из этого запроса.

## 15. Паттерн Подписчик-Издатель (Наблюдатель, Observer)
### Паттерн Прокси - проблемы
Если объект меняется, заместитель должен как-то узнать, что он поменялся. Должна быть какая-то рефлексия. Если объект меняется, пускай он вызовет какой-то метод нашего объекта. Издатель должен держать список пар - для какого объекта и какой метод вызывать. Например, лифт. На прибытие его может подписаться не только один человек. Подписчиков может быть много. По логике должен держать `weak_ptr`. Но в современных языках они держат "жестко" (`shared_ptr`). В какой-то степени это хорошо. Значит, что пока издатель жив, значит и все подписчики живы.

**Проблема**
Подписчик может играть роль издателя для самого издателя. Возникают кольца. Если не разрываем кольца, то возникает утечка памяти. В других языках, если на кольцо нет ни одного указателя, то сборщик мусора такие кольца уничтожает. Надо не только подписываться, но и отписываться от события. `Subscribe`, `Unsubscribe`. Паттерн довольно тяжелый. В каждом объекте, который выступает издаталем, нужно держать список подписчиков.

**Идея:** вынести все эти связи в отдельню сущность и все объекты будут иметь связь только с этой сущностью. То есть связи будут в этом объекте.

Если надо послать кому-то сообщение, мы обращаемся к этому объекту, а он уже распространяет это сообщение другим.
Мы должны по запросу решать, кто может его обработать. Или его должны обрабатывать все Это удобно, когда мы хотим передать сообщение всем

## 16. Паттерн Посредник (Медиатор)
В прошлом паттерне подписываться на события могут только родственные объекты. Это нормально (например, лифтом пользуются только люди). В `медиаторе` мы тоже должны держать список. Все объекты, которые работают с медиатором, должны быть родственниками.  
Что должно быть у объекта? Он должен подписаться у медиатора. И он должен иметь метод, который передает запрос, но и он должен от медиатора принимать запрос. У всех родственников должен быть такой интерфейс.  
Такая проблема решается через адаптер. Объекты, которые между собой не связаны, будут работать через единый интерфейс адаптера.  

Паттерн тяжелый, т.к. медиатор должен держать в себе все связи.
### Проблема колец для медиатора
Так же как и в подписчик-издатель мы должны подписаться (принять медиатор и медиатор держит указатель на нас).  
Объект должен держать `shared_ptr` на медиатор. А медиатору не важно, поэтому он может держать `weak_ptr`. Соответственно, не будет возникать проблемы колец.  
Паттерны команда, цепочка обязанностей, подписчик-издатель, посредник решают проблему передачи данных из интерфейса в прикладной домен  

## 17. Паттерн снимок (memnto)
Представим, что в редакторе что-то написали. И хотим вернуться к предыдущему сохранению (откатить изменения). Нужно держать состояние объекта. Чтобы откатиться, нужно восстановить его. Это не должен делать сам объект, т.к. получается несколько ответственностей.

**Идея:** вынести эту ответственность в отдельный объект. Нужно держать предыдущее состояние объекта

## 18. Опекун (Caretaker)
Есть снимки — простой класс. Опекун держит снимки. Он дергает соответствующий метод объекта, получает снимок и хранит этот снимок.
Какой может быть снимок?

- Если объект тяжелый, то снимок будет тяжелый - плохо.
- Частичный снимок
- - Смотрим только то что изменяется.

Два этих паттерна отвечают за историю изменений. Уходим от реализации к обобщению. Паттерны: Адаптер и Стратегия.

**Пробемы Адаптера:**
- Много кода
- Мы должны расширить существующий интерфейс на основе того интерфейса, который есть у объекта. Практически всегда это невозможно.

**Решаем:** реализуем дружбу (но она есть только в C++) и Мост.

## 19. Паттерн Посетитель (Visitor)
```c++
class Visitor
{
public:
    virtual void visit(Model&) = 0; // Можно принимать не Model а ModelImpl (паттерн Мост) - избавление от дружбы.
    virtual void visit(Camera&) = 0;
};

class DrawVisitor : public Visitor
{
public:
    void visit(Model&) override;
    void visit(Camera&) override;
};

class MoveVisitor : public Visitor
{
public:
    void visit(Model&) override;
    void visit(Camera&) override;
};

void Model::accept(shared_ptr<Visitor> vt)
{
    vt->visit(*this);
}
```

**Проблема:** А может ли visit реализовать перенос, отрисовку на основе интерфейса нашей сущности? Наверное, нет. Поэтому, применяем дружбу и Мост. Если применяем Мост, то по сути можно избавиться от дружбы.

Для стратегии можно не реализовывать некоторые вещи, например невозможно маштабировать точечный источник света. Мы должны для соответствующего Visitor-a заглушки.